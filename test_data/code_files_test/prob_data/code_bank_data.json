{
  "name": "Code Bank Pilot1 Smoke Test Problems",
  "version": "0.99",
  "Evaluation_Version": "Pilot1",
  "code_list": [
    {
      "trial_id": "00001_add",
      "testing_import_statement": "from genai_code_file import add",
      "source": "HumanEval",
      "source_text": "HumanEval/53",
      "lines_per_method": "3",
      "num_methods": "1",
      "imports_used": "no",
      "category": "simple",
      "primary_method_name": "add",
      "specification": "def add(x: int, y: int) -> int:\n    \"\"\"\n    Given two integers x, and y, return the sum of x and y. If either x or y is not\n    an integer, raise a TypeError Exception.\n    \"\"\"\n",
      "code_correct": "def add(x: int, y: int) -> int:\n    if ((not isinstance(x, int)) or isinstance(x, bool)) or ((not isinstance(y, int)) or isinstance(y, bool)):\n        raise TypeError('Inputs x and y must both be integers.')\n    return x + y\n",
      "code_incorrect_1": "def add(x: int, y: int) -> int:\n    if ((not isinstance(x, int)) or isinstance(x, bool)) or ((not isinstance(y, int)) or isinstance(y, bool)):\n        raise TypeError('Inputs x and y must both be integers.')\n    return x + 2*y\n",
      "code_incorrect_t": "def add(x: int, y: int) -> int:\n    return x + y\n",
      "baseline_reference_test_code": "from genai_code_file import add\nimport pytest\nimport random\n\nclass TestCode(object):\n    def test_reference(self):\n        assert add(0, 1) == 1\n        assert add(1, 0) == 1\n        assert add(2, 3) == 5\n        assert add(5, 7) == 12\n        assert add(7, 5) == 12\n\n        for i in range(100):\n            x, y = random.randint(0, 1000), random.randint(0, 1000)\n            assert add(x, y) == x + y\n\n    def test_additional_cases(self):\n        assert add(0, 0) == 0\n        assert add(-5, 5) == 0\n        assert add(-5, -5) == -10\n        assert add(13, -12) == 1\n        assert add(-7, 3) == -4\n\n    def test_additional_types(self):\n        with pytest.raises(TypeError):\n            add(\"abc\", 5)\n        with pytest.raises(TypeError):\n            add(3.2, 4.6)\n        with pytest.raises(TypeError):\n            add(7, 5.3)\n        with pytest.raises(TypeError):\n            add(\"abc\", \"def\")\n\n",
      "baseline_two_test_code": "from genai_code_file import add\nimport pytest\n\nclass TestCode(object):\n    def test_add(self):\n        assert add(2, 3) == 5\n        with pytest.raises(TypeError):\n            add(\"abc\", \"def\")"
    },
    {
      "trial_id": "00002_heap_queue_largest",
      "testing_import_statement": "from genai_code_file import heap_queue_largest",
      "source": "MBPP",
      "source_text": "Benchmark Questions Verification V2.ipynb, 4",
      "lines_per_method": "10",
      "num_methods": "1",
      "imports_used": "yes",
      "category": "simple",
      "primary_method_name": "heap_queue_largest",
      "specification": "from typing import Union\ndef heap_queue_largest(nums: list[Union(int, float)], n: int) ->  list[Union[int, float]]:\n    \"\"\"\n    Given a list of real numbers nums and a positive integer n, return the n largest numbers in list num\n    as a list of numbers in descending order. If nums is not a list of floats or n is not an integer,\n    raise a TypeError exception. If n is an integer less than 1 or greater than the length of nums, raise a ValueError exception.\n    \"\"\"\n",
      "code_correct": "import heapq as hq\nfrom typing import Union\n\ndef heap_queue_largest(nums: list[Union[int, float]], n: int) -> list[Union[int, float]]:\n    if not isinstance(nums, list):\n         raise TypeError('Input nums must be a list of real numbers.')\n    if not all([(isinstance(i, (int, float)) and (not isinstance(i, bool))) for i in nums]):\n         raise TypeError('Input nums must be a list of real numbers.')\n    if not isinstance(n, int):\n        raise TypeError('Input n must be a positive integer.')\n    if n <= 0 or n > len(nums):\n        raise ValueError('Input n must be a positive integer shorter than the length of the list.')\n    largest_nums = hq.nlargest(n, nums)\n    return largest_nums\n\n",
      "code_incorrect_1": "import heapq as hq\nfrom typing import Union\n\ndef heap_queue_largest(nums: list[Union[int, float]], n: int) -> list[Union[int, float]]:\n    if not isinstance(nums, list):\n         raise TypeError('Input nums must be a list of real numbers.')\n    if not all([(isinstance(i, (int, float)) and (not isinstance(i, bool))) for i in nums]):\n         raise TypeError('Input nums must be a list of real numbers.')\n    if not isinstance(n, int):\n        raise TypeError('Input n must be a positive integer.')\n    if n <= 0 or n > len(nums):\n        raise ValueError('Input n must be a positive integer shorter than the length of the list.')\n    largest_nums = hq.nlargest(n, nums[1:])\n    return largest_nums\n",
      "code_incorrect_t": "import heapq as hq\nfrom typing import Union\n\ndef heap_queue_largest(nums: list[Union[int, float]], n: int) -> list[Union[int, float]]:\n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums\n",
      "baseline_reference_test_code": "from genai_code_file import heap_queue_largest\nimport pytest\n\nclass TestCode(object):\n    def test_reference(self):\n        assert heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58],3) == [85, 75, 65]\n        assert heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58],2) == [85, 75]\n        assert heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58],5) == [85, 75, 65, 58, 35]\n\n    def test_additional_cases(self):\n        assert heap_queue_largest([15.2, 13.8, 19, 22.5, 24], 1) == [24]\n        assert heap_queue_largest([15.2, 13.8, 19, 22.5, 24], 2) == [24, 22.5]\n        assert heap_queue_largest([101.3, 13.8, 19, 22.5, 24.8], 2) == [101.3, 24.8]\n\n    def test_additional_types(self):\n        with pytest.raises(TypeError):\n            heap_queue_largest(\"abcde\", 3)\n        with pytest.raises(TypeError):\n            heap_queue_largest([\"abcde\", \"bcdef\", \"efghij\"], 3)\n        with pytest.raises(ValueError):\n            heap_queue_largest([15.2, 13.8, 19, 22.5, 24], 0)\n        with pytest.raises(ValueError):\n            heap_queue_largest([15.2, 13.8], 3)",
      "baseline_two_test_code": "from genai_code_file import heap_queue_largest\nimport pytest\n\nclass TestCode(object):\n    def test_heap_queue_largest(self):\n        assert heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3) == [85, 75, 65]\n        with pytest.raises(TypeError):\n            heap_queue_largest([\"abcde\", \"bcdef\", \"efghij\"], 3)\n\n"
    },
    {
      "trial_id": "00003_make_palindrome",
      "testing_import_statement": "from genai_code_file import make_palindrome, is_palindrome",
      "source": "HumanEval",
      "source_text": "HumanEval/10",
      "lines_per_method": "6.5",
      "num_methods": "2",
      "imports_used": "no",
      "category": "extended",
      "primary_method_name": "make_palindrome",
      "specification": "def make_palindrome(st: str) -> str:\n    \"\"\"\n    Given a string st, return the shortest palindrome that begins with the supplied string str. A palindrome is a string\n    that reads the same when read backwards or forwards. If st is not a string, raise a TypeError exception.\n    \"\"\"\n",
      "code_correct": "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\ndef make_palindrome(st: str) -> str:\n    if not isinstance(st, str):\n      raise TypeError('Input st must be a string.')\n    if not st:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(st[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return st + st[:beginning_of_suffix][::-1]\n",
      "code_incorrect_1": "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\ndef make_palindrome(st: str) -> str:\n    if not isinstance(st, str):\n      raise TypeError('Input st must be a string.')\n    if not st:\n        return ''\n\n    beginning_of_suffix = 1\n\n    while not is_palindrome(st[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return st + st[:beginning_of_suffix][::-1]\n",
      "code_incorrect_t": "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\ndef make_palindrome(st: str) -> str:\n    if not st:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not is_palindrome(st[beginning_of_suffix:]):\n        beginning_of_suffix += 1\n\n    return st + st[:beginning_of_suffix][::-1]\n",
      "baseline_reference_test_code": "from genai_code_file import make_palindrome\nimport pytest\n\nclass TestCode(object):\n    def test_reference(self):\n        assert make_palindrome('') == ''\n        assert make_palindrome('cat') == 'catac'\n        assert make_palindrome('cata') == 'catac'\n        assert make_palindrome('') == ''\n        assert make_palindrome('x') == 'x'\n        assert make_palindrome('xyz') == 'xyzyx'\n        assert make_palindrome('xyx') == 'xyx'\n        assert make_palindrome('jerry') == 'jerryrrej'\n\n    def test_additional_cases(self):\n        assert make_palindrome('racecar') == 'racecar'\n        assert make_palindrome('hataho') == 'hatahohatah'\n\n    def test_additional_types(self):\n        with pytest.raises(TypeError):\n            make_palindrome([5672])\n",
      "baseline_two_test_code": "from genai_code_file import make_palindrome\nimport pytest\n\nclass TestCode(object):\n    def test_make_palindrome(self):\n        assert make_palindrome('cat') == 'catac'\n        with pytest.raises(TypeError):\n            make_palindrome([5672])\n"
    },
    {
      "trial_id": "00004_unique",
      "testing_import_statement": "from genai_code_file import unique",
      "source": "HumanEval",
      "source_text": "HumanEval/34",
      "lines_per_method": "5",
      "num_methods": "1",
      "imports_used": "no",
      "category": "simple",
      "primary_method_name": "unique",
      "specification": "from typing import Union\ndef unique(l: Union[list[Union[int, float]], list[str]]) -> Union[list[Union[int, float]], list[str]]:\n    \"\"\"\n    Given a list of elements l, return the unique elements of l as a list of elements in sorted (ascending) order.\n    l is a list of real numbers or l is a list of strings.\n    If l is not a list whose elements are either all real numbers or all strings, throw a TypeError exception.\n    \"\"\"",
      "code_correct": "from typing import Union\n\ndef unique(l: Union[list[Union[int, float]], list[str]]) -> Union[list[Union[int, float]], list[str]]:\n    if not isinstance(l, list):\n      raise TypeError('Input l must be a list of elements that are all strings or all real numbers.')\n    if not (all([(isinstance(i, float) or isinstance(i, int)) for i in l]) or all([isinstance(i, str) for i in l])):\n      raise TypeError('Input l must be a list of elements that are all strings or all real numbers.')\n    return sorted(list(set(l)))\n",
      "code_incorrect_1": "from typing import Union\n\ndef unique(l: Union[list[Union[int, float]], list[str]]) -> Union[list[Union[int, float]], list[str]]:\n    if not isinstance(l, list):\n      raise TypeError('Input l must be a list of elements that are all strings or all real numbers.')\n    if not (all([(isinstance(i, float) or isinstance(i, int)) for i in l]) or all([isinstance(i, str) for i in l])):\n      raise TypeError('Input l must be a list of elements that are all strings or all real numbers.')\n    return list(set(l))\n",
      "code_incorrect_t": "from typing import Union\n\ndef unique(l: Union[list[Union[int, float]], list[str]]) -> Union[list[Union[int, float]], list[str]]:\n    return sorted(list(set(l)))",
      "baseline_reference_test_code": "from genai_code_file import unique\nimport pytest\n\nclass TestCode(object):\n    def test_reference(self):\n        assert unique([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n\n    def test_additional_cases(self):\n        assert unique([17, 12, 14, 17, 12, 15]) == [12, 14, 15, 17]\n        assert unique([15.12, 53, 15.12]) == [15.12, 53]\n        assert unique([]) == []\n        assert unique([0]) == [0]\n        assert unique([1.5, -4.3, 1, 10, 3.7]) == [-4.3, 1, 1.5, 3.7, 10]\n\n    def test_additional_types(self):\n        with pytest.raises(TypeError):\n            unique(\"abcde\")\n        with pytest.raises(TypeError):\n            unique([\"abcde\", True, 15])\n        with pytest.raises(TypeError):\n            unique([\"abcde\", 15.12, 15])\n        with pytest.raises(TypeError):\n            unique([15.12, \"apple\", \"diagram\", 53, 15.12, \"apple\"])",
      "baseline_two_test_code": "from genai_code_file import unique\nimport pytest\n\nclass TestCode(object):\n    def test_unique(self):\n        assert unique([5, 3, 5, 2, 3, 3, 9, 0, 123]) == [0, 2, 3, 5, 9, 123]\n        with pytest.raises(TypeError):\n            unique(\"abcde\")\n"
    }
  ]
}
